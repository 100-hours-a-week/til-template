# 📚 Today I Learn

## 2025-02-05

### 오늘 배운 내용

# NumPy 심화

## Numpy는 무엇인가?

넘파이의 핵심은 ndarray이다. 배열 안 모든 원소들이 같은 자료형으로 구성된 형태이며 성능적인 측면을 위해서 이를 채택했다.

파이썬의 경우에선 배열의 내부 요소들의 자료형을 제한하지 않지만 numpy에서는 이러한 제한을 사용하여 계산방식을 변화시켜 성능을 개선하였다. (넘파이는 C언어 방식으로 동작 - elementwise)

## Numpy는 왜 빠른가?

벡터화를 지원하기 때문이다.

데이터를 하나씩 보는 것이 아닌 수를 모아 일관적으로 계산을 수행하여 속도를 높였다.

## Numpy 기본 및 사용법

https://numpy.org/doc/stable/user/basics.creation.html

## 배열 생성방식

넘파이의 배열을 만드는 것은 6가지의 방식이 있다.

1. 다른 Python 구조(예: 목록 및 튜플)에서 변환
2. 내재적인 NumPy 배열 생성 함수(예: arange, ones, zeros 등)
3. 기존 배열 복제, 결합 또는 변형
4. 표준 또는 사용자 정의 형식 중 하나에서 디스크에서 배열 읽기
5. 문자열이나 버퍼를 사용하여 원시 바이트에서 배열 생성
6. 특수 라이브러리 함수 사용(예: random)

## 인덱싱 방법

인덱싱의 방식은 기존 파이썬의 배열에 접근하는 것과 비슷하지만 차이가 있다.

- 1차원 a[0]
- 2차원 a[1][2], a[1,2]

## Copy & View

넘파이에선 배열을 작업할 때 데이터를 복사하지 않고 뷰에서도 내부 데이터에 직접 액세스 할 수 있다.

### **Shallow Copy**

```python
import numpy as np
x = np.arange(10)
x
y = x[1:3]  # creates a view
y
x[1:3] = [10, 11]
x #array([ 0, 10, 11,  3,  4,  5,  6,  7,  8,  9])
y #array([10, 11])

```

y를 변경시켰더니 x가 같이 바뀜 (기존 파이썬에서는 슬라이싱은 딥카피임)

### **Deep copy**

```python
import numpy as np
x = np.arange(9).reshape(3, 3)
y = x[[1, 2]]
y     # array([[3, 4, 5], [6, 7, 8]])
x[[1, 2]] = [[10, 11, 12], [13, 14, 15]]
x     # array([[ 0,  1,  2],[10, 11, 12],[13, 14, 15]])
y     # array([[3, 4, 5], [6, 7, 8]])

```

## Broadcasting

배열끼리의 차원이 일치하지 않을 때 이를 맞추어 연산을 수행

```python
import numpy as np
a = np.array([1.0, 2.0, 3.0])
b = np.array([2.0, 2.0, 2.0])
a * b
>>> array([2.,  4.,  6.])

```

차원이 일치하는 경우 각 요소에 대한 벡터화된 연산을 수행

### **차원이 다른 경우엔?**

```python
import numpy as np
a = np.array([1.0, 2.0, 3.0])
b = 2.0
a * b
>>> array([2.,  4.,  6.])

```

다음 그림과 같이 배열 중 높은 차원에 맞추어 데이터를 복제하여 사용하듯이 연산이 진행

실제로 메모리상 복제가 일어나지는 않음
