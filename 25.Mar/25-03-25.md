## 날짜 : 2025-03-25

### 스크럼
1. 개념 정리
2. 앞서 정리한 내용들 잊지 않게 다시 보기
3. 과제 진행
4. 알고리즘 1문제라도
5. JS 책읽기, CSS 공부

### 새로 배운 내용
#### 주제 1: Redis
<aside>
📌

Redis

- Remote Dictionary Server (이걸 줄여서 Redis 라고 부른다)
- 특징
    - 인메모리 데이터 저장소
    - 디스크와 같은 일반적 저장소가 아닌 램을 이용하는 방식 (그러니까 빠름)
    - 싱글 스레드 기반 (멀티 스레드를 지원하면 좋겠지만 복잡도 이슈 때문에 과감히 싱글 스레드 채택)
    - 클러스터 모드 지원
        - 분산 DB에 데이터를 저장 → 안정성과 고가용성을 챙김
    - 주로 휘발성의 데이터를 다루지만 RDB와 AOF (Append Only File) 특성을 통해 영속적으로 관리도 가능
    - Pub/Sub 기술 자체 구현,

장점

- Cache의 특성에 기반
    - 빠른 메모리 접근 속도 (당연한 얘기. Cache에 비해 disk I/O에 대한 속도는 100배 가까이 차이 나니까,,,)
- 다양한 data type 지원, 백엔드와의 연동이 쉬움

Redis 영속성

- Redis는 주로 RAM의 특성을 활용해 캐싱에 주로 사용되지만 영속성을 목적으로 하는 옵션을 제공하기도 함.
- RDB
    - 특정 시점의 DB에 대한 스냅샷을 생성. 이걸 활용해서 장애 발생 시 특정 시점으로의 롤백, 특정 시점의 데이터를 빠르게 복사하는 데 사용
    - 특정 시점을 기준으로 하는 것이기 때문에 스냅샷 생성 이전에 지워지거나 변경된 내용의 추적은 어려울 수도 있음
    - 스냅샷 생성 과정에서 스냅샷 생성에 일부 리소스를 할당하기 때문에 Redis 전체로 봤을 때는 요청 처리에 max utilization을 달성하지 못함
- AOF (Append Only File)
    - 레디스에 적용되는 write 작업을 log로 저장
    - 거의 모든 데이터 온전 가능, 장애가 발생해서 복구를 해야할 때 모든 로그를 적용해야 하므로 스냅샷 방식의 복구보다는 시간이 오래 걸림

캐싱

- CPU 캐시 - CPU - RAM 간 오버헤드를 줄이기 위해 CPU와 RAM 간 캐시 테이블을 생성해서 관리함
    - RAM이 빠르다고 해도 CPU에 비할 바는 못됨 → 따라서 일종의 테이블을 통해 한 번 방문했던 메모리에 대한 정보를 빼두고 다시 해당 캐시가 요구되는 상황에 RAM에 접근하는게 아니라 캐시에 있는 값을 가져다가 쓰도록 함
- 웹 브라우저 캐싱
    - 웹 브라우저가 특정 페이지 방문 시 해당 페이지에 접근했었다라는 기록을 남김
        - 캐시 형태로 로컬 저장소에 보관
        - 재방문 시 로컬 저장소에 보관된 캐시를 사용
- DNS 캐싱
    - 이전에 조회한 도메인 이름 - 그에 대응되는 IP 서버를 DNS 서버 상에 저장
        - 재요청 시 DNS query를 통해 DNS에 대한 정보를 가져오는 과정을 거치지 않고 DNS cache에 있는 정보를 활용
- CDN (Content Delivery Network)
    - 이미지/동영상 등 용량이 큰 파일을 PoP 서버에 저장 (전 세계 여러 곳에 존재)
    - 사용자 요청이 있을 시 사용자와 가장 가까운 거리에 있는 PoP 서버에서 파일에 대한 정보를 보내도록 함
- DB 캐싱
    - db 조회, 계산 결과를 캐싱해두었다가 재요청 시 사용 (Index)
- 어플리케이션 캐싱
    - 어플리케이션의 데이터, 계산 결과를 캐싱해둬 반복 작업 최적화
</aside>




### 오늘의 도전 과제와 해결 방법
- 과제의 고도화 방안으로 테스트 코드 작성을 진행했다. 단위 테스트와 함께 일종의 성능 테스트를 할 수 있는 방법들에 대해 고민했던 것 같다. 우선적으로 고려했던 부분은 커뮤니티 서비스 간 발생할 수 있을만한 예외 상황들에 대한 테스트 코드 작성이었던 것 같다. 그 중에서도 집중했던 부분은 동시성과 관련된 테스트 코드였다. 해당 부분 구현에 있어 JPA의 @Transactional 특성에 의해 AOP proxy 방식으로 구현되어 synchronized와 같은 원자성을 보장하는 방식이 먹히지 않는다는 것을 알았다. 이후, 해당 부분의 해결을 위해 방법들을 탐색해 보았고, 특정 IP에 대해 API 호출을 시간 당 제한을 두는 것과 전송 데이터를 기준으로 hashkey를 생성해 중복된 내용이라면 동작이 실행되지 않는 방식으로 구현을 진행했다.

### 오늘의 회고
-  테스트 코드 진행 과정에서 단위 테스트를 진행하며 BE에서도 FE와 마찬가지로 모종의 예외 처리에 대한 필요성을 느꼈던 것 같다.
